//////////////////////////////////////////////////////////////////////////////////
//
// Montek Singh
// 4/3/2019
//
//////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps
`default_nettype none

module top #(

    parameter Dbits=32,                                 // word size for the processor
    parameter Nreg=32,                                  // number of registers

    parameter imem_size=512,                            // imem size, must be >= # instructions in program
    parameter imem_init="imem_screentest_nopause.mem",  // use this line for simulation/testing
    //parameter imem_init="imem_screentest.mem",          // use this line for synthesis/board deployment

    parameter dmem_size=64,                             // dmem size, must be >= # words in .data of program + size of stack
    parameter dmem_init="dmem_screentest.mem",          // file to initialize data memory

    parameter smem_size=1200,                           // smem size, is 1200 for our chosen screen grid of 40x30
    parameter smem_init="smem_screentest.mem", 	        // file to initialize screen memory

    parameter bmem_size=1024,                           // bmem size, 256 * # of characters.  For 4 chars, = 1024.
    parameter bmem_init="bmem_screentest.mem" 	        // file to initialize bitmap memory
)(
    input wire clk, reset,
    						// add I/O signals here
    					   // incl. VGA signals
   //Sound
    output wire audPWM,
    output wire audEn,
    
    //Accel
    output wire aclSCK,
    output wire aclMOSI,
    input wire aclMISO,
    output wire aclSS,
    
    //Display
    output wire [7:0] segments,
    output wire [7:0] digitselect,
    
    //LED
    output wire [15:0] LED,
    
    //Keyboard
    input wire ps2_data,
	input wire ps2_clk,
	
	//VGA Display Driver
	output  wire [3:0] red, green, blue,
    output wire hsync, vsync
);

   wire enable = 1'b1;      // Available for debugging purposes.

   wire [31:0] pc, instr, mem_readdata, mem_writedata, mem_addr;
   wire mem_wr;
   wire clk100, clk50, clk25, clk12;

   wire [10:0] smem_addr;
   wire [3:0] charcode;                                 // increase #bits if using more than 16 characters
   wire [31:0] keyb_char;  
  
   wire [31:0] lights, period;
   
   wire [8:0] accelX, accelY;
   wire [11:0] accelTmp;
   
   wire [31:0] accel_val = {7'b0, accelX, 7'b0, accelY};
   
   assign audEn = 1'b1;
  
   // Uncomment *only* one of the following two lines:
   //    when synthesizing, use the first line
   //    when simulating, get rid of the clock divider, and use the second line
   //
   clockdivider_Nexys4 clkdv(clk, clk100, clk50, clk25, clk12);   // use this line for synthesis/board deployment
   //assign clk100=clk; assign clk50=clk; assign clk25=clk; assign clk12=clk;  // use this line for simulation/testing

   // For synthesis:  use an appropriate clock frequency(ies) below
   //   clk100 will work for hardly anyone
   //   clk50 or clk 25 may work for some
   //   clk12 should work for everyone!  So, please use clk12 for your processor and data memory.
   //
   // Important:  Use the same clock frequency for the MIPS and the memIO modules.
   // The I/O devices, however, should keep the 100 MHz clock.
   // For example:

   mips #(.Dbits(Dbits), .Nreg(Nreg)) mips(clk12, reset, enable, pc, instr, mem_wr, mem_addr, mem_writedata, mem_readdata);

   rom_module #(.Nloc(imem_size), .Dbits(Dbits), .initfile(imem_init)) imem(pc[31:2], instr);      
                // dropped two LSBs from address to instr mem to convert byte address to word address

   memIO #(
     .dmem_size(dmem_size), .Dbits(Dbits), .dmem_init(dmem_init), 
     .smem_size(smem_size), .smem_init(smem_init)
                    // any other parameters you need  
   ) memIO(clk12, mem_wr, mem_addr, mem_writedata, accel_val, keyb_char, smem_addr, mem_readdata, lights, period, charcode);

   // I/O devices
   //
   // Note: All I/O devices were developed assuming a 100 MHz clock.
   //   Therefore, the clock sent to them must be clk100, not any of the
   //   slower clocks generated by the clock divider.
  
   vgadisplaydriver #(.bmem_size(bmem_size), .bmem_init(bmem_init)) display(clk100, charcode, smem_addr, red, green, blue, hsync, vsync );

   // Uncomment the following to instantiate these other I/O devices.
   //   You will have to declare all the wires that connect to them.
   //
   keyboard keyb(clk100, ps2_clk, ps2_data, keyb_char); 
   display8digit disp(keyb_char, clk100, segments, digitselect);
   accelerometer accel(clk100, aclSCK, aclMOSI, aclMISO, aclSS, accelX, accelY, accelTmp);
   montek_sound_Nexys4 sound(clk100, period, audPWM);
   
   //LED lights 
   assign LED[15:0] =  (
        (accelY >= 12'h000 && accelY <= 12'h01F) ? 16'b0000000000000001
      : (accelY > 12'h01F && accelY <= 12'h03F) ? 16'b0000000000000010
      : (accelY > 12'h03F && accelY <= 12'h05F) ? 16'b0000000000000100
      : (accelY > 12'h05F && accelY <= 12'h07F) ? 16'b0000000000001000
      : (accelY > 12'h07F && accelY <= 12'h09F) ? 16'b0000000000010000
      : (accelY > 12'h09F && accelY <= 12'h0BF) ? 16'b0000000000100000
      : (accelY > 12'h0BF && accelY <= 12'h0DF) ? 16'b0000000001000000
      : (accelY > 12'h0DF && accelY <= 12'h0FF) ? 16'b0000000010000000
      : (accelY > 12'h0FF && accelY <= 12'h11F) ? 16'b0000000100000000
      : (accelY > 12'h11F && accelY <= 12'h13F) ? 16'b0000001000000000
      : (accelY > 12'h13F && accelY <= 12'h15F) ? 16'b0000010000000000
      : (accelY > 12'h15F && accelY <= 12'h17F) ? 16'b0000100000000000
      : (accelY > 12'h17F && accelY <= 12'h19F) ? 16'b0001000000000000
      : (accelY > 12'h19F && accelY <= 12'h1BF) ? 16'b0010000000000000
      : (accelY > 12'h1BF && accelY <= 12'h1DF) ? 16'b0100000000000000
      : (accelY > 12'h1DF && accelY <= 12'h1FF) ? 16'b1000000000000000
      : 16'b1111111111111111
    );  

endmodule